# -*- coding: utf-8 -*-
"""kusuma.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iCxiXf3m3debPZkkOkRng8CLQ4Dc5G3u
"""

import math
def rlc_impedance(R,L,C,f):
    xl=2*math.pi*f*L
    xc=1/(2*math.pi*f*C)
    return math.sqrt(R**2+(xl-xc)**2)
R=100
L=0.5
C=1e-6
f=50
print("RLC Circuit impedance:",rlc_impedance(R,L,C,f),"ohms")



mport math
def three_phase_power(V_line,l_line,power_factor):
  return math.sqrt(3)*V_line*l_line*power_factor
  print("Three-Phase Power:",three_phase_power(415,10,0.9),"Watts")0

beam_id="B12"
length_m=5.5
is_safe=True
materials=["steel","concrete"]



density=7850
volume=0.002
mass=density*volume
print("mass(kg):",mass)



stress=250
if stress>300:
  print("Fail")
elif stress>250:
  print("Near Failure")
else:
  print("safe")

for load in[100,200,300]:
  print("load:",load)
  count=0
  while count<3:
    print("count:",count)
    count+=1

def beam_volume(l,b,h):
 return l*b*h
print("volume:",beam_volume(5,0.3,0.5))

from collections.abc import ItemsView
lengths=[4,5,6]
breadths=[3,3.5,4]
areas=[l*b for l,b in zip(lengths,breadths)]
print("Areas:",areas)
gear_data={"G1":(20,40),"G2":(1-5,45)}
ratios={k:driven/driving for k,(driving,driven)in gear_data.items()}
print(ratios)

def beam_ids(n):
  for i in range(1,n+1):
    yield f"B{i}"
for beam in beam_ids(3):
  print (beam)

effeciencies=[0.85,0.9,0.92,0.8]
high=list(filter(lambda e:e>0.88,effeciencies))
print("High effeciency:",high)
forces=[100,200,300]
distances=[2,3,4]
moments=[f*d for f,d in zip(forces,distances)]
print("moments:",moments)

def _init_(self,l, b ,h, cost_per_m3):
    self.l=l
    self.b=b
    self.h=h
    self.cost_per_m3=cost_per_m3
def volume(self):
  return self.l*self.b*self.h
def total_cost(self):
  return self.volume()*self.cost_per_m3
slab=concreteslab(10,5,0.2,3500)
print("Volume:",slab.volume(),"m3")
print("Total Cost:",slab.total_cost(),"INR")

import math
class ThreePhasePower:
  def __init__(self, V,I, pf):
    self.V=V
    self.I=I
    self.pf =pf
  def power(self):
    return math.sqrt(3)*self.V * self.I * self.pf
    tp=ThreePhasePower(400,50,0.9)
    print("Three-Phase Power:",round(tp.power(),2),"W")

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Generate a noisy signal (sine wave + noise)
fs = 500  # Sampling frequency
t = np.linspace(0, 1, fs, endpoint=False)
clean_signal = np.sin(2 * np.pi * 50 * t)  # 50 Hz sine wave
noise = np.random.normal(0, 0.5, clean_signal.shape)
noisy_signal = clean_signal + noise

# Design a low-pass FIR filter (cutoff = 100 Hz)
nyq = fs / 2  # Nyquist frequency
cutoff = 100  # Hz
numtaps = 101
fir_coeff = signal.firwin(numtaps, cutoff/nyq)

# Apply FIR filter
filtered_signal_fir = signal.lfilter(fir_coeff, 1.0, noisy_signal)

# Design a low-pass IIR filter (Butterworth)
order = 4
b, a = signal.butter(order, cutoff/nyq, btype='low')
filtered_signal_iir = signal.filtfilt(b, a, noisy_signal)

# Plot results
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(t, noisy_signal, label="Noisy Signal")
plt.plot(t, clean_signal, label="Clean Signal", alpha=0.7)
plt.legend()
plt.title("Original and Noisy Signal")

plt.subplot(3, 1, 2)
plt.plot(t, filtered_signal_fir, label="FIR Filtered", color='orange')
plt.legend()
plt.title("FIR Filter Output")

plt.subplot(3, 1, 3)
plt.plot(t, filtered_signal_iir, label="IIR Filtered", color='green')
plt.legend()
plt.title("IIR Filter Output")

plt.tight_layout()
plt.show()

# Frequency response of FIR filter
w, h = signal.freqz(fir_coeff, worN=8000)
plt.figure()
plt.plot(0.5*fs*w/np.pi, np.abs(h), 'b')
plt.title("FIR Filter Frequency Response")
plt.xlabel('Frequency (Hz)')
plt.ylabel('Gain')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# --- DC motor parameters ---
J = 0.01   # kg·m^2
b = 0.1    # N·m·s
K = 0.01   # N·m/A  (also V·s/rad)
R = 1.0    # ohm
L = 0.5    # H

# Motor transfer function G(s) = K / (JLs^2 + (JR+Lb)s + (Rb + K^2))
numG = [K]
denG = [J*L, J*R + L*b, R*b + K**2]

# --- PID controller C(s) = Kd s + Kp + Ki/s = (Kd s^2 + Kp s + Ki) / s ---
Kp, Ki, Kd = 100.0, 200.0, 10.0
numC = [Kd, Kp, Ki]
denC = [1.0, 0.0]

# Open loop: OL(s) = C(s)G(s) = N(s)/D(s)
numOL = np.convolve(numC, numG)
denOL = np.convolve(denC, denG)

# Closed loop with unity feedback: T(s) = OL / (1 + OL) = N / (D + N)
numCL = numOL
denCL = np.polyadd(denOL, numOL)

# LTI system and step response
sys = signal.TransferFunction(numCL, denCL)
t = np.linspace(0, 2.0, 1000)
t, y = signal.step(sys, T=t)

plt.figure(figsize=(10, 6))
plt.plot(t, y, label="Speed (rad/s) for 1-rad/s step")
plt.xlabel("Time (s)")
plt.ylabel("Speed (rad/s)")
plt.title("DC Motor Speed Control with PID (SciPy only)")
plt.grid(True)
plt.legend()
plt.show()

from scipy.optimize import fsolve
def eq(x):
  return 3*x**2-x-1
root=fsolve(eq,0)
print('Root:',root)

import numpy as np
samples=np.random.normal(50,5,10000)
failure_rate=np.mean(samples>60)
print('Failure Rate:',failure_rate*100,'%')

